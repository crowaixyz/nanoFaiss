package nanofaiss

import (
	"fmt"
	"os"
	"testing"

	. "github.com/smartystreets/goconvey/convey"
)

var index_flat IndexFlat

var vecs = [][]float64{
	{-1.9868, 5.6860, -3.3291, -7.0557, 3.5151, -2.2679, -5.9550, 6.9650, 9.8572, -4.5050, -9.4050, -6.7393, 7.4610, 1.0083, 9.8969, -3.1486},
	{-1.8844, -6.6207, 7.0316, 3.9971, -2.3031, -5.7606, -5.8476, -2.5007, 3.4979, -1.1782, -1.3401, 1.0967, -1.2712, -4.9789, -9.0890, -4.1150},
	{9.6805, -2.0903, -5.9735, 6.6838, 7.9909, -9.7308, 4.6712, 7.3035, -5.5592, -6.5468, 9.3354, 4.0835, -6.8329, -6.5936, -1.0223, 4.1134},
	{9.1343, 0.4023, 5.7710, -4.4378, 6.6000, -8.5159, -1.3144, 0.8215, 0.6810, -8.1890, -7.9119, 4.3616, -1.0799, -6.3421, 7.6390, -9.3325},
	{0.5826, 6.9317, -7.8957, 9.6471, 6.3228, -8.3741, -7.9894, 5.2890, 6.9059, 6.1816, 3.0310, 3.0108, 6.9355, -8.2554, -5.8582, 2.6959},
	{-1.9528, -9.4549, 8.5244, -3.5117, 5.1243, -5.5617, 5.3453, 0.6389, 8.6911, 0.7602, -5.8969, 0.4683, 9.5739, 4.1150, -7.2324, -0.4839},
	{0.2355, 2.4510, 4.9197, 4.4732, -0.3681, 2.3228, 8.4153, -8.8818, -5.2794, 1.5773, -5.9531, -7.6634, 9.6905, -1.6469, -6.8518, 1.1332},
	{-6.6470, -8.5638, 8.1416, 0.6188, 6.8358, 2.5415, 5.5035, 2.9408, -6.0126, 3.8511, -3.1609, -9.2893, 9.3241, 3.9992, -0.4900, -1.8301},
	{-6.6470, -8.5638, 8.1416, 0.6188, 6.8358, 2.5415, 5.5035, 2.9408, -6.0126, 3.8511, -3.1609, -9.2893, 9.3241, 3.9992, -0.4900, -1.8301},
	{-7.2993, 6.4648, 8.8036, -2.8147, -6.3769, -7.2858, -7.9217, -2.2623, -2.7153, 1.9199, 0.9847, 1.8002, -1.0400, 1.1877, -9.9490, 2.4744},
}

func setup() {
	num := int32(10)
	dim := int32(16)
	index_flat.Init(num, dim)
}

func TestMain(m *testing.M) {
	setup()
	os.Exit(m.Run())
}

func TestAdd(t *testing.T) {
	Convey("Add", t, func() {
		type args struct {
			x [][]float64
		}
		tests := []struct {
			name string
			args args
		}{
			{
				name: "test case 1",
				args: args{
					x: vecs,
				},
			},
		}

		for _, tt := range tests {
			Convey(tt.name, func() {
				for _, v := range tt.args.x {
					index_flat.Add(v)
				}

				So(index_flat.size, ShouldEqual, int32(len(tt.args.x)))

				for i := 0; i < len(tt.args.x); i++ {
					fmt.Println(index_flat.vecs[i])
					So(index_flat.vecs[i].RawVector().Data, ShouldResemble, tt.args.x[i])
				}
			})
		}
	})
}

func TestSearch(t *testing.T) {
	Convey("Search", t, func() {
		q := []float64{6.6541, 9.1702, 7.5098, -8.3963, 4.3156, -5.5704, -4.3876, -2.0011, -2.1687, 3.2732, 3.5592, 5.8669, -8.0175, 9.9450, -6.2154, 3.7234}

		type args struct {
			x           []float64
			k           int32
			metric_type MetricType
		}
		tests := []struct {
			name      string
			args      args
			want_vecs [][]float64
			want_idxs []int32
		}{
			{
				name: "test case 1: METRIC_L2",
				args: args{
					x:           q,
					k:           3,
					metric_type: METRIC_L2,
				},
				want_vecs: [][]float64{
					{-1.8844, -6.6207, 7.0316, 3.9971, -2.3031, -5.7606, -5.8476, -2.5007, 3.4979, -1.1782, -1.3401, 1.0967, -1.2712, -4.9789, -9.0890, -4.1150},
					{9.1343, 0.4023, 5.7710, -4.4378, 6.6000, -8.5159, -1.3144, 0.8215, 0.6810, -8.1890, -7.9119, 4.3616, -1.0799, -6.3421, 7.6390, -9.3325},
					{-7.2993, 6.4648, 8.8036, -2.8147, -6.3769, -7.2858, -7.9217, -2.2623, -2.7153, 1.9199, 0.9847, 1.8002, -1.0400, 1.1877, -9.9490, 2.4744},
				},
				want_idxs: []int32{1, 3, 9},
			},
			{
				name: "test case 2: METRIC_IP",
				args: args{
					x:           q,
					k:           4,
					metric_type: METRIC_IP,
				},
				want_vecs: [][]float64{
					{9.6805, -2.0903, -5.9735, 6.6838, 7.9909, -9.7308, 4.6712, 7.3035, -5.5592, -6.5468, 9.3354, 4.0835, -6.8329, -6.5936, -1.0223, 4.1134},
					{9.1343, 0.4023, 5.7710, -4.4378, 6.6000, -8.5159, -1.3144, 0.8215, 0.6810, -8.1890, -7.9119, 4.3616, -1.0799, -6.3421, 7.6390, -9.3325},
					{-1.9528, -9.4549, 8.5244, -3.5117, 5.1243, -5.5617, 5.3453, 0.6389, 8.6911, 0.7602, -5.8969, 0.4683, 9.5739, 4.1150, -7.2324, -0.4839},
					{-7.2993, 6.4648, 8.8036, -2.8147, -6.3769, -7.2858, -7.9217, -2.2623, -2.7153, 1.9199, 0.9847, 1.8002, -1.0400, 1.1877, -9.9490, 2.4744},
				},
				want_idxs: []int32{2, 3, 5, 9},
			},
			{
				name: "test case 3: METRIC_COSINE",
				args: args{
					x:           q,
					k:           5,
					metric_type: METRIC_COSINE,
				},
				want_vecs: [][]float64{
					{-1.8844, -6.6207, 7.0316, 3.9971, -2.3031, -5.7606, -5.8476, -2.5007, 3.4979, -1.1782, -1.3401, 1.0967, -1.2712, -4.9789, -9.0890, -4.1150},
					{9.6805, -2.0903, -5.9735, 6.6838, 7.9909, -9.7308, 4.6712, 7.3035, -5.5592, -6.5468, 9.3354, 4.0835, -6.8329, -6.5936, -1.0223, 4.1134},
					{9.1343, 0.4023, 5.7710, -4.4378, 6.6000, -8.5159, -1.3144, 0.8215, 0.6810, -8.1890, -7.9119, 4.3616, -1.0799, -6.3421, 7.6390, -9.3325},
					{-1.9528, -9.4549, 8.5244, -3.5117, 5.1243, -5.5617, 5.3453, 0.6389, 8.6911, 0.7602, -5.8969, 0.4683, 9.5739, 4.1150, -7.2324, -0.4839},
					{-7.2993, 6.4648, 8.8036, -2.8147, -6.3769, -7.2858, -7.9217, -2.2623, -2.7153, 1.9199, 0.9847, 1.8002, -1.0400, 1.1877, -9.9490, 2.4744},
				},
				want_idxs: []int32{1, 2, 3, 5, 9},
			},
		}

		for _, tt := range tests {
			Convey(tt.name, func() {
				got_idxs, got_vecs := index_flat.Search(tt.args.x, tt.args.k, tt.args.metric_type)
				So(got_idxs, ShouldResemble, tt.want_idxs)
				So(got_vecs, ShouldResemble, tt.want_vecs)
			})
		}
	})
}
